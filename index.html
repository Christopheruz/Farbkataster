<!DOCTYPE html>
<html lang="de">     
<head>
  <meta charset="UTF-8" />
  <title>CoLiBri - Farbtonarchiv</title>
  <link rel="stylesheet" href="style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
  <link rel="icon" href="favicon.ico">
</head>
<body>
<header class="site-header">
  <nav class="navbar">
    <!-- Upload zuerst (links) -->
    <div class="header-actions">
      <input type="file" id="fileInput" accept=".xlsx,.xls" class="visually-hidden" />
      <label for="fileInput" class="btn">Excel-Datei auswählen</label>
      <span id="fileName" class="file-name" aria-live="polite"></span>
    </div>

    <!-- Links danach (rückt nach rechts) -->
    <div class="links">
      <a href="#">Start</a>
      <a href="#" aria-current="page">Excel laden</a>
      <a href="#">Kontakt</a>
    </div>
  </nav>
</header>



  <div class="page-background">
    <main class="container">
  <details class="intro-card intro-collapsible" id="intro" open>
  <summary>
    <span>CoLiBri – Die Farbtonbibliothek · Kurz-Anleitung</span>
  </summary>
  <div class="intro-content">  
  <h1>CoLiBri - Die Farbtonbibliothek - Kurz-Anleitung</h1>
  <h3>1. Excel laden</h3>  
    <p>Wähle oben im Header die aktuellste Excel-Datei aus dem Ordner Farbtonverzeichnis aus.</p>
    <p>Die Seite funktioniert offline. Es erfolgt kein Upload – alles bleibt lokal im Browser.</p>
  <h3>2. Filtern</h3>  
    <p>In der Sidebar kannst du live nach Daten filtern</p> 
  <h3>3. Einträge hinzufügen</h3>
    <p>Füge durch den Button "Einträge hinzufügen" einen neuen Eintrag hinzu. Alle 4 Felder müssen ausgefüllt sein. </p> 
    <p>Die Einträge werden sofort in der Tabelle ergänzt und lokal im Browser gespeichert.</p> 
    <p>Die lokale Speicherung sorgt dafür, dass deine neuen Einträge beim nächsten Laden der Excel-Datei automatisch wieder eingefügt werden. Ein Speichern ist nur beim Datenexport notwendig</p>
  <h3>4. Speichern & Datei versenden</h3> 
    <p>Durch klicken des Button "Excel speichern" wird die Excel-Datei im Download-Ordner gespeichert, optional kann im Feld Bearbeiter dein Name eingetragen werden (Dateiname: Originalname-Bearbeiter.xlsx). </p> 
    <p>Durch das Speichern wird die lokale Speicherung im Browser gelöscht um doppelte Einträge zu vermeiden</p> 
    <p>Es öffnet sich eine neue E-Mail mit Betreff „aktuelle Farbtondatenbank“. Folge den Anweisungen in der E-Mail um deine Excel-Datei zu versenden</p>
  <h3>5. wichtiger Hinweis</h3>  
    <p>Alle Fartonangaben sind ohne Gewähr und vor Ort zu prüfen.</p>
  </div>
</details>

  <div class="layout">
    <!-- Sidebar (links) -->
    <aside class="sidebar">

      <div class="sidebar-logo">
    <img src="colibrilogo.png" alt="Farbarchiv Logo">
  </div>
      <h2 class="sidebar-title">Filter</h2>

      <div class="filter-group">
        <label for="filterGebaeude">Gebäude</label>
        <input type="text" id="filterGebaeude" placeholder="z. B. 3800, Parkhaus …">
      </div>

      <div class="filter-group">
        <label for="filterRaum">Raumnr.</label>
        <input type="text" id="filterRaum" placeholder="z. B. E 05, 090.110, Flur …">
      </div>

      <button type="button" id="clearFilters" class="btn btn-clear">Filter zurücksetzen</button>
      <p class="hint">Die Filter wirken auf die geladene Tabelle.</p>
    </aside>

    <!-- Tabelle (rechts) -->
    <section class="main">
  <!-- Eingabezeile oberhalb der Tabelle -->
  <div class="entry-sticky">    
  <div class="entry-bar">
    
    <div class="entry-fields">
      <div class="field">
       <label for="addGebSel">Gebäude</label>
        <select id="addGebSel">
         <option value="">– bitte wählen –</option>
        </select>
       </div>
     <div class="field">
        <label for="addRaum">Raumnr.</label>
        <input type="text" id="addRaum" placeholder="z. B. E 05, 090.110, Flur …">
      </div>
      <div class="field">
        <label for="addFarb">Farbton</label>
        <input type="text" id="addFarb" placeholder="z. B. RAL 9010 …">
      </div>
      <div class="field">
        <label for="addProd">Produkt</label>
        <input type="text" id="addProd" placeholder="z. B. Hersteller …">
      </div>
      
    </div>

    <div class="entry-actions">
      <button type="button" id="addRow" class="btn btn-primary">Eintrag hinzufügen</button>
      <input id="bearbeiter" class="fn-input" placeholder="Bearbeiter" aria-label="Bearbeiter">
      <button type="button" id="saveExcel" class="btn btn-save">Excel speichern</button>
      <div id="entryError" class="form-error" role="alert" aria-live="polite"></div> 
     </div>
   </div>
  </div>  

  <!-- Tabelle -->
  <div id="output" class="table-wrap"></div>
</section>

  </div>
</main>

  </div>
  
  <script>
  const intro = document.getElementById('intro');
  if (intro) {
    const KEY = 'introOpen';
    const saved = localStorage.getItem(KEY);
    if (saved !== null) intro.open = saved === '1';
    intro.addEventListener('toggle', () => {
      localStorage.setItem(KEY, intro.open ? '1' : '0');
    });
  }
</script>

  
  <script src="gebaeude-list.js"></script>
  <script src="xlsx.full.min.js"></script>
<script>
  const fileInput  = document.getElementById('fileInput');
  const fileNameEl = document.getElementById('fileName');
  const outputEl   = document.getElementById('output');
  const bearbeiter = document.getElementById('bearbeiter');

  // Filter aus der Sidebar (falls vorhanden)
  const inpGebFilter  = document.getElementById('filterGebaeude');
  const inpRaumFilter = document.getElementById('filterRaum');
  const btnClear      = document.getElementById('clearFilters');

  // Neue Eingabefelder (oberhalb der Tabelle)
  const addGebSel = document.getElementById('addGebSel');
  const addRaum = document.getElementById('addRaum');
  const addFarb = document.getElementById('addFarb');
  const addProd = document.getElementById('addProd');
  const btnAdd  = document.getElementById('addRow');
  const btnSave = document.getElementById('saveExcel');

  // Arbeitszustand
  let wb = null, ws = null, sheetName = null;
  let aoa = [];                         // Array-of-Arrays
  let tableEl = null;
  let originalFileName = 'Tabelle.xlsx';

  // Spaltenindex
  let colIdx = { geb: null, raum: null, farb: null, prod: null };

  // ---------- Utils
  function normalizeHeader(text) {
    return String(text || '')
      .toLowerCase()
      .replace(/\s+/g, '')
      .replace(/[.\-]/g, '')
      .replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue');
  }

  function fillGebaeudeSelect(list) {
    const arr = (Array.isArray(list) ? list : []).map(s => String(s||'').trim()).filter(Boolean)
                  .sort((a,b) => a.localeCompare(b, 'de'));
    addGebSel.innerHTML = '<option value="">– bitte wählen –</option>';
    for (const name of arr) {
      const opt = document.createElement('option');
      opt.value = name; opt.textContent = name;
      addGebSel.appendChild(opt);
    }
  }
  // Beim Laden der Seite füllen (offline: aus window.GEBAEUDE_LIST)
  document.addEventListener('DOMContentLoaded', () => {
    fillGebaeudeSelect(window.GEBAEUDE_LIST || []);
  });

  function ensureHeaders() {
    if (!Array.isArray(aoa) || aoa.length === 0) {
      aoa = [['Gebäude','Raumnr.','Farbton','Produkt']];
      return;
    }
    if (!Array.isArray(aoa[0])) aoa[0] = Array.from(aoa[0]);

    const headersNorm = aoa[0].map(h => normalizeHeader(h));
    const pushIfMissing = (label, ...needles) => {
      const exists = headersNorm.some(h => needles.some(n => h.includes(n)));
      if (!exists) aoa[0].push(label);
    };
    pushIfMissing('Gebäude', 'gebaeude');
    pushIfMissing('Raumnr.', 'raumnr','raumnummer','raum');
    pushIfMissing('Farbton', 'farbton','farb','farbcode','farbnummer','farbtonnr');
    pushIfMissing('Produkt', 'produkt','artikel','produktname','artikelnummer');
  }

  function findHeaderIndexesFromAoa() {
    const H = aoa[0].map(h => normalizeHeader(h));
    const findIdx = (cands) => {
      for (let i=0;i<H.length;i++) {
        for (const c of cands) if (H[i].includes(c)) return i;
      }
      return null;
    };
    colIdx.geb  = findIdx(['gebaeude']);
    colIdx.raum = findIdx(['raumnr','raumnummer','raum']);
    colIdx.farb = findIdx(['farbton','farb','farbcode','farbnummer','farbtonnr']);
    colIdx.prod = findIdx(['produkt','artikel','produktname','artikelnummer']);
  }

  // ---------- Rendern
  function renderAndSetup() {
    ws = XLSX.utils.aoa_to_sheet(aoa);
    wb.Sheets[sheetName] = ws;
    const html = XLSX.utils.sheet_to_html(ws, { header: "", footer: "" });
    outputEl.innerHTML = html;
    tableEl = outputEl.querySelector('table');
    setupFiltering();
  }

  // ---------- Filtern (nur Gebäude/Raum – wie zuvor)
  function findHeaderIndexesForFilter() {
    if (!tableEl) { colIdx.geb = colIdx.geb ?? null; colIdx.raum = colIdx.raum ?? null; return; }
    const headerRow = tableEl.tHead?.rows?.[0] || tableEl.rows?.[0];
    if (!headerRow) return;
    const headers = Array.from(headerRow.cells).map(th => normalizeHeader(th.textContent));

    const idxOfAny = (cands) => {
      for (let i=0;i<headers.length;i++) {
        for (const c of cands) if (headers[i].includes(c)) return i;
      }
      return null;
    };
    colIdx.geb  ??= idxOfAny(['gebaeude']);
    colIdx.raum ??= idxOfAny(['raumnr','raumnummer','raum']);
  }

  function getDataRows() {
    if (!tableEl) return [];
    if (tableEl.tBodies && tableEl.tBodies.length && tableEl.tBodies[0].rows.length) {
      return Array.from(tableEl.tBodies[0].rows);
    }
    return Array.from(tableEl.rows).slice(1);
  }

  function applyFilters() {
    if (!tableEl) return;
    const fGeb  = (inpGebFilter?.value  || '').toLowerCase().trim();
    const fRaum = (inpRaumFilter?.value || '').toLowerCase().trim();

    const rows = getDataRows();
    for (const row of rows) {
      if (!row || row.cells.length === 0) continue;
      const okGeb  = !fGeb  || colIdx.geb  == null || (row.cells[colIdx.geb]  && row.cells[colIdx.geb].textContent.toLowerCase().includes(fGeb));
      const okRaum = !fRaum || colIdx.raum == null || (row.cells[colIdx.raum] && row.cells[colIdx.raum].textContent.toLowerCase().includes(fRaum));
      row.style.display = (okGeb && okRaum) ? '' : 'none';
    }
  }

  function setupFiltering() { findHeaderIndexesForFilter(); applyFilters(); }

  async function appendLocalEntries() {
  const saved = await LocalDB.all();
  if (!saved.length) return;
  const cols = aoa[0].length;
  for (const e of saved) {
    const r = new Array(cols).fill('');
    if (colIdx.geb  != null) r[colIdx.geb]  = e.geb;
    if (colIdx.raum != null) r[colIdx.raum] = e.raum;
    if (colIdx.farb != null) r[colIdx.farb] = e.farb;
    if (colIdx.prod != null) r[colIdx.prod] = e.prod;
    aoa.push(r);
  }
}

  // ---------- Datei laden
  fileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) { if (fileNameEl) fileNameEl.textContent = ''; return; }
    originalFileName = file.name;
    if (fileNameEl) fileNameEl.textContent = originalFileName;

    const reader = new FileReader();
    reader.onload = async function(e) {
      const data = new Uint8Array(e.target.result);
      wb = XLSX.read(data, { type: 'array' });
      sheetName = wb.SheetNames[0] || 'Tabelle1';
      ws = wb.Sheets[sheetName];

      aoa = XLSX.utils.sheet_to_json(ws, { header: 1 }) || [];
      ensureHeaders();
      findHeaderIndexesFromAoa();
      await appendLocalEntries(); 
      renderAndSetup();
    };
    reader.readAsArrayBuffer(file);
  });

  // ---------- Zeile hinzufügen aus 4 Feldern
  const entryError = document.getElementById('entryError');
  
  btnAdd?.addEventListener('click', () => {
  if (!wb || !aoa.length) { alert('Bitte zuerst eine Excel-Datei laden.'); return; }

  const g = (addGebSel.value || '').trim();
  const r = (addRaum.value   || '').trim();
  const f = (addFarb.value   || '').trim();
  const p = (addProd.value   || '').trim();

  // Validierung: alle müssen vorhanden sein
  const missing = [];
  if (!g) missing.push(addGebSel);
  if (!r) missing.push(addRaum);
  if (!f) missing.push(addFarb);
  if (!p) missing.push(addProd);

    

  // Markieren + Meldung
  [addGebSel, addRaum, addFarb, addProd].forEach(el => {
    const empty = !(el.value || '').trim();
    el.classList.toggle('invalid', empty);
  });

  if (missing.length) {
    entryError.textContent = 'Bitte alle Felder ausfüllen.';
    missing[0].focus();
    return;
  } else {
    entryError.textContent = '';
  }

  ensureHeaders();
  findHeaderIndexesFromAoa();

  const cols = aoa[0].length;
  const row = new Array(cols).fill('');
  if (colIdx.geb  != null) row[colIdx.geb]  = g;
  if (colIdx.raum != null) row[colIdx.raum] = r;
  if (colIdx.farb != null) row[colIdx.farb] = f;
  if (colIdx.prod != null) row[colIdx.prod] = p;

  aoa.push(row);
    
  LocalDB.add({ geb: g, raum: r, farb: f, prod: p, created: Date.now() })
  .catch(console.warn);


  // Felder leeren
  addGebSel.value = '';
  addRaum.value = '';
  addFarb.value = '';
  addProd.value = '';

  

 renderAndSetup();
});

// Invalid-Markierung live entfernen
addGebSel?.addEventListener('change', () => {
  if ((addGebSel.value || '').trim()) addGebSel.classList.remove('invalid');
  if ([addGebSel, addRaum, addFarb, addProd].every(el => (el.value || '').trim()))
    entryError.textContent = '';
});
[addRaum, addFarb, addProd].forEach(el => {
  el?.addEventListener('input', () => {
    if ((el.value || '').trim()) el.classList.remove('invalid');
    if ([addGebSel, addRaum, addFarb, addProd].every(x => (x.value || '').trim()))
      entryError.textContent = '';
  });
});

  // ---------- Excel speichern
  btnSave?.addEventListener('click', async () => {
  if (!wb) { alert('Keine Daten zum Speichern. Bitte zuerst eine Excel-Datei laden.'); return; }

  // Dateinamen bauen (inkl. Bearbeiter)
  const isXlsm = /\.xlsm$/i.test(originalFileName);
  const ext  = isXlsm ? '.xlsm' : '.xlsx';
  const base = (originalFileName || 'Export.xlsx').replace(/\.(xlsx?|xlsm)$/i, '') || 'Export';
  const tagRaw = (bearbeiter?.value || '').trim();
  const tagSan = tagRaw.replace(/[\\/:*?"<>|]+/g, '').replace(/\s+/g, '_');
  const finalName = base + (tagSan ? '-' + tagSan : '') + ext;

  // 1) Excel speichern (Download)
  XLSX.writeFile(wb, finalName);

  // 2) Lokale (IndexedDB) Einträge löschen
  try { await LocalDB.clear(); } catch (e) { console.warn('LocalDB.clear() Fehler:', e); }

  // 3) Outlook öffnen (mailto) – Anhang muss auf file:// manuell hinzugefügt werden
  const subject = 'aktuelle Farbtondatenbank';
  const bodyLines = [
    'Hallo,',
    '',
    'anbei die aktuelle Farbtondatenbank.',
    '',
    `Dateiname: ${finalName}`,
    '',
    'Hinweis: Bitte die gespeicherte Excel-Datei manuell als Anhang hinzufügen (meist im Download-Ordner).'
  ];
  const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(bodyLines.join('\r\n'))}`;

  // kleiner Delay, damit der Download-Dialog nicht vom Mailto überholt wird
  setTimeout(() => { window.location.href = mailto; }, 350);
});


  // Live-Filter (Sidebar)
  inpGebFilter?.addEventListener('input', applyFilters);
  inpRaumFilter?.addEventListener('input', applyFilters);
  btnClear?.addEventListener('click', () => { if (inpGebFilter) inpGebFilter.value=''; if (inpRaumFilter) inpRaumFilter.value=''; applyFilters(); });
</script>

  
<script>
/* ========== Offline-Datenbank (IndexedDB) ========== */
const LocalDB = (() => {
  const DB = 'farbarchiv', STORE = 'eintraege', VERSION = 1;
  let db;
  function open() {
    return new Promise((res, rej) => {
      const req = indexedDB.open(DB, VERSION);
      req.onupgradeneeded = () => {
        const d = req.result;
        if (!d.objectStoreNames.contains(STORE)) {
          const s = d.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
          s.createIndex('created','created');
        }
      };
      req.onsuccess = () => res(req.result);
      req.onerror   = () => rej(req.error);
    });
  }
  async function ready(){ return db || (db = await open()); }
  async function add(entry){
    const d = await ready();
    return new Promise((res, rej) => {
      const tx = d.transaction(STORE,'readwrite');
      tx.objectStore(STORE).add(entry);
      tx.oncomplete = () => res();
      tx.onerror    = () => rej(tx.error);
    });
  }
  async function all(){
    const d = await ready();
    return new Promise((res, rej) => {
      const tx = d.transaction(STORE,'readonly');
      const rq = tx.objectStore(STORE).getAll();
      rq.onsuccess = () => res(rq.result || []);
      rq.onerror   = () => rej(rq.error);
    });
  }
  async function clear(){
    const d = await ready();
    return new Promise((res, rej) => {
      const tx = d.transaction(STORE,'readwrite');
      tx.objectStore(STORE).clear();
      tx.oncomplete = () => res();
      tx.onerror    = () => rej(tx.error);
    });
  }
  return { add, all, clear };
})();
</script>

  </body>
</html>





